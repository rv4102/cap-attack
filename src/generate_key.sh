#!/bin/bash

# Initial hexadecimal key
initial_key="FFFF00000000FFFF0F0F0F0FF0F0F0F0"
echo "Initial key: $initial_key"

# Split the initial_key into bytes and store in a tuple (array)
initial_key_tuple=()
for ((i=0; i<${#initial_key}; i+=2)); do
    byte="0x${initial_key:i:2}"
    initial_key_tuple+=("$byte")
done

# Print the tuple containing each byte of the initial key
echo "Initial key bytes as tuple: (${initial_key_tuple[*]})"

# Run aes.cpp to generate traces using the initial key bytes as input
sudo taskset -c 1 ./aes "${initial_key_tuple[@]}"
echo "Traces generated by aes.cpp with initial key bytes."

# Array to store generated subkeys, starting with initial_key_tuple as the first element
subkeys=()

./hamming

# Loop from 0 to 15 to generate subkeys
for i in {0..15}; do
    new_subkey=$(python3 cpa.py results/traces.csv results/hamm"$i".csv)
    
    # Append the new subkey (output from cpa.py) to the list of subkeys
    subkeys+=("$new_subkey")
    
    echo "Generated subkey $i: $new_subkey"
done

# Print the final list of subkeys
echo "Final list of subkeys: ${subkeys[@]}"

# Actual Final Round Key:   0x06 0x14 0x96 0x15 0xdb 0x0b 0x38 0xfe 0xc5 0x28 0x61 0x38 0x22 0x6a 0x25 0xbb
# Predicted Final Round Key:0xb8 0x63 0xfd 0x92 0xf0 0xec 0x95 0xde 0xef 0x8e 0x0a 0x3e 0xc8 0x69 0x1d 0x07